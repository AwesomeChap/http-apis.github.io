---
layout: page
title: Workflow | Hydraecosystem.org
permalink: /Workflow
---

# Workflow: Developing APIs with Hydra

A Developer wishing to design and deploy his/her own data services with Hydra, [hydrus](https://github.com/HTTP-APIs/hydrus) (the server) and [Hydra agent](https://github.com/HTTP-APIs/hydra-python-agent) (the client)
has to go through a workflow that is defined by multiple steps: from defining the best Hydra/RDF/OpenAPI description of the
resources and operations he/she is going to provide, to create the conditions for the services to be deployed by hydrus and for the agent to access them. 

<img src="static/hydra workflow - horizontal.png"/>

In general, the workflow is made up of these basic steps:
1. The Developer defines an API description in the shape of an RDF-compliant or Hydra-compliant JSON-LD (Hydra is an RDF vocabulary itself) or in the shape of an OpenAPI data structure (see [OpenAPI-to-Hydra parser](https://github.com/HTTP-APIs/hydra-openapi-parser)). Any shape that is supplied it is parsed into an Hydra-compliant JSON-LD that becomes the API documentation (in Hydra parlance: the `ApiDoc`). Every REST resource is identified by an `HydraClass`.
2. [hydrus](https://github.com/HTTP-APIs/hydrus) toolkit can parse the `ApiDoc` and define handlers to support the pusblishing of the resources as described by the Developer; if configured, it puts in place a system for credentials management to secure the endpoints with Two-factors token authentication. Every `HydraClass` has its endpoint and HTTP methods and related operations as defined by the documentation. It may be possible in future to deploy every `HydraClass` in a "database per service" fashion, all the server instances generated by the same `ApiDoc` share the same hydrus's RDF graph storage, so to allow access to other instances' resources in case of `hydra:search` (query on multiple resources) operations.
3. [Hydra agent](https://github.com/HTTP-APIs/hydra-python-agent) reads the `ApiDoc` via the entrypoint and parses the JSON-LD into an internal representation (a graph) that allows the client to proceed to query the endpoints for its searching, storing or retrieving necessities. The internal representation may change on-the-fly or grow depending from the different `ApiDoc` that the clients reaches. The official Hydra client implementation is [Heracles.ts](https://github.com/HydraCG/Heracles.ts).

In general, an Hydra network is made up by the interaction of an instance of Hydra agent with one or more instances of hydrus. An Hydra agent is an HTTP client with capabilities of translating REST queries from-to a graph query language, so to allow efficient navigation of the graph's internal representation (see [this paragraph](/Design#hydrus-as-a-full-stack-module) in Design).

Follow [Example](Example.md) shown below for a more in depth explanation.

# Flock Demo

Assume a small simulation consisting of 5 different Web APIs featuring a flock of drones. 5 different APIs are-
* Central Controller: `http://127.0.0.1:8080/api`
* Drone 1: `http://127.0.0.1:8081/api`
* Drone 2: `http://127.0.0.1:8081/api`
* Drone 3: `http://127.0.0.1:8081/api`
* Drone 4: `http://127.0.0.1:8081/api`

You can find demo [here](http://flockdemo.hydraecosystem.org). It basically consists of 3 major things.
GUI: It’s the first thing you see when you open the demo. You can use it to interact with the server.
Controller: It’s a central hydra server which will start, stop drones and also send orders to them.
Flock of drones: A group of drones which aim to detect fire or abnormal heat spots in a given geographical area, each drone can be active or not active at a given moment. They receive instructions from Controller and report back in every 15 sec.

Assuming that you have already visited the demo. You might have came across various sections and might be curious what each one of them really means. So let’s study each one of them. We’ll go from left to right, would first study all the sections at left side and then would study sections right to it. So here we go!

First up there is an input field which you can use to give instructions to an individual drone, for eg you can change the speed of any drone by writing `Set Drone 1 speed 10`. As you might have already figured out. This message is first sent to controller via GUI and then controller takes some action depending on input supplied to it. Action can be change in speed of a particular drone(eg input: `Set Drone 2 speed 100`), It can be change in direction of a particular drone (eg input: `Set Drone 8 direction N`). It can be change in status (eg input: 13 status off or 8 status active). 

 (Change the speed of drone with id 2 to 100 Km/h.)
Set Drone 8 direction N (Change the direction of drone with id 8 to North.)
Set Drone 13 status off (Turn drone with id 13 off.)
Set Drone 8 status active (Turn drone with id 8 on.)

Next up is the Refresh Button, which you can use to reload active drones at any moment.

Next up is the HTTP-API Logs Section. When some instructions are sent to drone they are sent via HTTP requests which can be either PUT or POST. This section logs all that activity. Now we are done with our left side and lets hop over to the right side and see what we can find over there.

In this side, we've got two log sections similar to controller log we talked about moments ago. Remember we logged type of request and target over there, and in the first section we log purpose of that request. Now you may be wondering what do mean by purpose where does it come from? So For your information it’s the same thing which you typed in the input field we discussed earlier and sent to controller. As we already know that each drone updates controller every 15 sec. So in the second/last section we log updates sent from drone to controller.

Now you might I have at least got an idea what every section means in the demo and basically what the demo is all about. But you must be having one question in your mind at the moment viz. Where is hydra? So the answer is it’s everywhere.It’s just that We haven’t discussed about it yet. Let’s begin!

The Web API discussed above has to expose representations of drones, datastreams, commands (sent via GUI), states (whether active or inactive), messages, log entries and areas. In order to make  interaction of these resources (data), client needs to be aware of operations supported by the server. In normal websites (websites not using hydra) such resources are made available via links/forms. But the problem is that they are not machine readable. Data represented in natural language can easily understood by humans but for machines/computers it’s just a collection of random bits which doesn’t convey any meaning to them. That’s where hydra comes to the rescue and we use it to resolve this issue.

Okay now that you know what demo is all about. You probably will want to play with it in a local environment, Below you can find pointwise instruction to achieve it. (One thing to keep in mind before moving any further is that you must be on a linux operating system with python3 installed in it. Python2 will not be useful).

* create and activate a new virtualenv
* upgrade pip and setuptools
* check if python3-dev is installed
* chmod +x bootstrap-dev.sh
* ./bootstrap-dev.sh
* chmod +x init.sh
* ./init.sh


---


